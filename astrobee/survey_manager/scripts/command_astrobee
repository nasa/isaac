#!/usr/bin/env python3
#
# Copyright (c) 2021, United States Government, as represented by the
# Administrator of the National Aeronautics and Space Administration.
# 
# All rights reserved.
# 
# The "ISAAC - Integrated System for Autonomous and Adaptive Caretaking
# platform" software is licensed under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with the
# License. You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

import argparse
import os
import select
import socket
import subprocess
import sys
import threading
import yaml
import pathlib

import rospy

from std_msgs.msg import String
from ff_msgs.msg import CommandArg, CommandStamped
from ff_msgs.msg import CommandConstants
from ff_msgs.msg import AckStamped, AckCompletedStatus

from typing import Any, Dict, List

# Type alias
YamlMapping = Dict[str, Any]

# Constants
MAX_COUNTER = 10

def exposure_change(bay_origin, bay_destination, value):
    # Going to JEM
    if bay_origin == "nod2_hatch_to_jem" and bay_destination == "jem_hatch_from_nod2":
        value = 100
        return True
    # Going  to NOD2
    if (bay_origin == "jem_hatch_to_nod2" and bay_destination == "nod2_hatch_from_jem"
        or bay_origin == "usl_hatch_to_nod2" and bay_destination == "nod2_hatch_from_usl"):
        value = 300
        return True
    # Going to USL
    if bay_origin == "nod2_hatch_to_usl" and bay_destination == "usl_hatch_from_nod2":
        value = 300
        return True
    return False

def map_change(bay_origin, bay_destination, map_name):
    # Going to JEM
    if bay_origin == "nod2_hatch_to_jem" and bay_destination == "jem_hatch_from_nod2":
        map_name = "iss.map"
        return True
    # Going  to NOD2
    if (bay_origin == "jem_hatch_to_nod2" and bay_destination == "nod2_hatch_from_jem"
        or bay_origin == "usl_hatch_to_nod2" and bay_destination == "nod2_hatch_from_usl"):
        map_name = "20220331_isaac5.map"
        return True
    # Going to USL
    if bay_origin == "nod2_hatch_to_usl" and bay_destination == "usl_hatch_from_nod2":
        map_name = "20220617_Isaac10_USLonly.map"
        return True


# This class starts a new process and lets you monitor the input and output
# Mostly used for actions where user inteference might be required
class ProcessExecutor:

    def __init__(self, robot_name, goal, bay, run):

        self.input_path = '/tmp/input_' + robot_name
        self.output_path = '/tmp/output_' + robot_name

        # Check if the file exists
        if os.path.exists(self.input_path):
            os.remove(self.input_path)
        if os.path.exists(self.output_path):
            os.remove(self.output_path)

        # Declare socket for process input
        self.sock_input = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.sock_input.settimeout(1)  # Set a timeout for socket operations
        self.sock_input.bind(self.input_path)
        self.sock_input.listen(1)  # Listen for one connection

        # Declare socket for process output
        self.sock_output = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.sock_output.settimeout(1)  # Set a timeout for socket operations
        self.sock_output.bind(self.output_path)
        self.sock_output.listen(1)  # Listen for one connection

        # Declare event that will stop input thread
        self._stop_event = threading.Event()


    def __del__(self):

        self.sock_input.close()
        self.sock_output.close()

    # def connect_input_callback(sock, addr):
    #     """Callback function that is called when a connection is made to the socket."""
    #     print("Input connection made from", addr)
    #     sock_input_connected = False

    # def connect_output_callback(sock, addr):
    #     """Callback function that is called when a connection is made to the socket."""
    #     print("Output connection made from", addr)
    #     sock_output_connected = False

    def thread_write_output(self, process):
        print("starting thread_write_output...")
        # Store cumulative output
        output_total = ""
        connected = False
        try:
            while True:
                # Get output from process
                output = process.stdout.readline()
                if (output == '' and process.poll() is not None) or self._stop_event.is_set():
                    break
                if output:
                    output_total += output

                # If socket is not connected try to connect
                if not connected:
                    try:
                        print("trying to connect")
                        conn, addr = self.sock_output.accept()
                        conn.setblocking(False)

                        connected = True
                        conn.send(output_total.encode("utf-8")[:1024])
                    except socket.timeout:
                        continue
                    except (socket.error, BrokenPipeError):
                        print("Error sending data. Receiver may have disconnected.")
                        connected = False

                # If socket is already connected, send output
                elif connected:
                    try:
                        conn.send(output.encode("utf-8")[:1024])
                    except (socket.error, BrokenPipeError):
                        print("Error sending data. Receiver may have disconnected.")
                        connected = False
        except Exception as e:
            print("exit output:")
            print(e)
        # finally:
        #     # Save total output into a log
        #     print(output_total)

    def thread_read_input(self, process):
        print("starting thread_read_input...")
        try:
            while True:
                while not self._stop_event.is_set():
                    print("waiting for connection")
                    try:
                        client_socket, client_address = self.sock_input.accept()
                        break
                    except socket.timeout:
                        continue
                if self._stop_event.is_set():
                    break
                client_socket.settimeout(1)  # Set a timeout for socket operations


                while True:
                    print("accepted connection:")
                    print(client_address)

                    while not self._stop_event.is_set():
                        print("waiting to receive")
                        try:
                            request = client_socket.recv(1024).decode("utf-8")
                            break
                        except socket.timeout:
                            continue
                    if self._stop_event.is_set():
                        break

                    # If broken pipe connect again
                    if not request:
                        break
                    print("got: " + request)

                    print(request)
                    process.stdin.write(request + "\n")
                    process.stdin.flush()
        except Exception as e:
            print("exit input:")
            print(e)


    def send_command(self, command):
        print(command)
        return_code = -1

        try:
            # Start the process
            process = subprocess.Popen(command, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

            # Start input and output threads
            input_thread = threading.Thread(target=self.thread_read_input, args=(process,))
            input_thread.start()
            output_thread = threading.Thread(target=self.thread_write_output, args=(process,))
            output_thread.start()

            output_thread.join()
            # Get the return code of the process
            return_code = process.poll()

        except Exception as e:
            print("exit main:")
            print(e)
            # Get the return code of the process
            process.kill()
        finally:
            # Forcefully stop the thread (not recommended)
            print("Killing input thread...")
            self._stop_event.set()
            input_thread.join()
            output_thread.join()  # In normal scenarios this should have already happened

        # Get the final exit code
        return return_code


    def recursive_command(self, command):
        while True:
            user_input = input("Do you want to continue? (y/n): ").lower().strip()
            if user_input == 'y':
                if send_command_with_input(command) != 0:
                    repeat_inspection()  # Continue recursively
                break
            elif user_input == 'n':
                print("Exiting.")
                break
            else:
                print("Invalid input. Please enter 'y' or 'n'.")

    def send_command_recursive(self, command):
        if send_command(command):
            recursive_command(command)


# This class sends a command to the executor and waits to get a response
# Mostly used for short actions that should be immediate and require no feedback
# This method is needed on actions that run remotely and are not controlled by topics
class CommandExecutor:


    def __init__(self, ns):
        self.ns = ns
        # Start ROS node
        rospy.init_node("survey_namager_cmd_" + robot_name)
        # Declare guest science command publisher
        self.pub_guest_sci = rospy.Publisher(self.ns + "command", CommandStamped, queue_size=5)

        self.unique_cmd_id = ""

    def __del__(self):
        rospy.shutdown()

    def start_recording():

        # Arg is bagfile name description
        arg1 = CommandArg()
        arg1.data_type = CommandArg.DATA_TYPE_STRING
        arg1.s = "Front"

        # Create CommandStamped message
        cmd_args = [arg1]

        cmd = CommandStamped()
        cmd.header = Header(stamp=rospy.Time.now())
        cmd.cmd_name = CommandConstants.CMD_NAME_START_RECORDING
        cmd.cmd_id = "survey_manager" + str(rospy.Time.now().to_sec())
        self.unique_cmd_id = cmd.cmd_id
        cmd.cmd_src = "isaac fsw"
        cmd.cmd_origin = "isaac fsw"

        # Publish the CommandStamped message
        result = publish_and_wait_response(cmd)

    def stop_recording(bag_description):
        cmd = CommandStamped()
        cmd.header = Header(stamp=rospy.Time.now())
        cmd.cmd_name = CommandConstants.CMD_NAME_STOP_RECORDING
        cmd.cmd_id = "survey_manager" + str(rospy.Time.now().to_sec())
        self.unique_cmd_id = cmd.cmd_id
        cmd.cmd_src = "isaac fsw"
        cmd.cmd_origin = "isaac fsw"

        # Publish the CommandStamped message
        result = publish_and_wait_response(cmd)

    def change_exposure(val):
        #TBD
        rospy.loginfo("Change exposure to " + val)

    def change_map(map_name):
        #TBD
        rospy.loginfo("Change map to " + map_name)

    def set_plan():
        # TODO Add call to plan_pub.cc

        cmd = CommandStamped()
        cmd.header = Header(stamp=rospy.Time.now())
        cmd.cmd_name = CommandConstants.CMD_NAME_SET_PLAN
        cmd.cmd_id = "survey_manager" + str(rospy.Time.now().to_sec())
        self.unique_cmd_id = cmd.cmd_id
        cmd.cmd_src = "isaac fsw"
        cmd.cmd_origin = "isaac fsw"
        cmd.args = cmd_args

        # Publish the CommandStamped message
        result = publish_and_wait_response(cmd)

    def run_plan():
        cmd = CommandStamped()
        cmd.header = Header(stamp=rospy.Time.now())
        cmd.cmd_name = CommandConstants.CMD_NAME_RUN_PLAN
        cmd.cmd_id = "survey_manager" + str(rospy.Time.now().to_sec())
        self.unique_cmd_id = cmd.cmd_id
        cmd.cmd_src = "isaac fsw"
        cmd.cmd_origin = "isaac fsw"

        # Publish the CommandStamped message
        result = publish_and_wait_response(cmd)

    def publish_and_wait_response(cmd):

        # Publish the CommandStamped message
        self.pub_guest_sci.publish(cmd)

        # Wait for ack
        counter = 0
        while counter < MAX_COUNTER:
            try:
                msg = rospy.wait_for_message(self.ns + "gt/ack", AckStamped, timeout = 5)
                if msg.cmd_id == self.unique_cmd_id:
                    if msg.completed_status.status == AckCompletedStatus.NOT:
                        rospy.loginfo("Command is being executed and has not completed.")
                    elif msg.completed_status.status == AckCompletedStatus.OK:
                        rospy.loginfo("Command completed successfully!")
                        return 0
                    else:
                        rospy.loginfo("Command failed! Message: " + Ack.message)
                        return 1
            except:
                continue
            counter += 1


def load_yaml(yaml_path: pathlib.Path) -> YamlMapping:
    """
    Return the YAML parse result for the file at `yaml_path`.
    """
    with yaml_path.open(encoding="utf-8") as yaml_stream:
        return yaml.safe_load(yaml_stream)

def get_stereo_traj(from_bay, to_bay):
    # Get stereo trajectory
    traj_matches = [
        traj
        for traj in static_config["stereo"].values()
        if traj["base_location"] == from_bay and traj["bound_location"] == to_bay
    ]
    assert (
        len(traj_matches) == 1
    ), f"Expected exactly 1 matching stereo trajectory with base {base} and bound {bound}, got {len(traj_matches)}"
    fplan = traj_matches[0]["fplan"]
    return fplan

def survey_manager_executor(robot_name, goal, to_bay, from_bay, run, config_static_path: pathlib.Path):

    # Read the static configs that convert constants to values
    config_static = load_yaml(config_static_path)

    sim = False
    # Figure out robot name and whether we are in simulation or hardware
    current_robot = os.environ.get('ROBOTNAME')
    if not current_robot:
        rospy.loginfo("We're in simulation. Let's get the robotname using the topic")
        # This is a latching messge so it shouldn't take long
        data = rospy.wait_for_message('/robot_name', String, timeout=2)
        current_robot = data.data.lower()
        sim = True

    ns = ""
    # If we're commanding a robot remotely
    if current_robot != robot_name:
        rospy.loginfo("We're commanding a robot remotely!")
        ns = " -remote -ns " + robot_name
        # Command executor will add namespace for bridge forwarding
        command_executor = CommandExecutor(robot_name + "/")
    else:
        command_executor = CommandExecutor("")
    process_executor = ProcessExecutor()

    # Initialize exit code
    exit_code = 0

    if goal == "dock":
        exit_code += process_executor.send_command_recursive("rosrun executive teleop -dock" + ns)

    elif goal == "undock":
        exit_code += process_executor.send_command_recursive("rosrun executive teleop -undock" + ns)

    elif goal == "move":
        exit_code += process_executor.send_command_recursive("rosrun executive teleop -move " + bay + ns)
        # Change exposure if needed
        if exposure_change(from_bay, to_bay, exposure_value):
            exit_code += command_executor.change_exposure(exposure_value)
        # Change map if needed
        if map_change(from_bay, to_bay, map_name):
            exit_code += command_executor.change_map(map_name)

    elif goal == "panorama":
        exit_code += command_executor.start_recording("pano_" + bay + "_" + run)
        exit_code += process_executor.send_command_recursive("rosrun inspection inspection_tool -panorama -panorama_mode '5_mapper_and_hugin' " + static_config["bays"][to_bay] + ns)
        exit_code += command_executor.stop_recording()

    elif goal == "stereo":
        exit_code += command_executor.start_recording("stereo_" + bay + "_" + run)
        exit_code += command_executor.set_plan("plans/ISAAC/" + get_stereo_traj(from_bay, to_bay))
        exit_code += command_executor.run_plan()
        exit_code += command_executor.stop_recording()

    return exit_code


class CustomFormatter(argparse.ArgumentDefaultsHelpFormatter):
    pass

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description=__doc__, formatter_class=CustomFormatter
    )

    parser.add_argument(
        "robot_name",
        default="",
        help="Robot name executing the command.",
    )
    parser.add_argument(
        "command_name",
        help="Prefix for bagfiles to merge. Bags should all be in the current working directory.",
    )
    parser.add_argument(
        "to_bay",
        default="",
        help="Target bay destination.",
    )
    parser.add_argument(
        "from_bay",
        default="",
        help="Target bay start.",
    )
    parser.add_argument(
        "run",
        default="",
        help="Run number, increases as we add attempts.",
    )
    parser.add_argument(
        "config_static",
        help="Path to input static problem config YAML (module geometry, available stereo surveys, etc.)",
        type=pathlib.Path,
        default="survey_constants.yaml",
    )
    args = parser.parse_args()

    exit_code = survey_manager_executor(args.robot_name, args.command_name, args.to_bay, args.from_bay, args.run, args.config_static)
